import fs from 'fs';
import path from 'path';
import { SFTPClient } from '~/services/sftp.service';

export default defineEventHandler(async (event) => {
  const formData = await readMultipartFormData(event);

  if (!formData || formData.length === 0) {
    return { message: 'Aucun fichier trouvé.', success: false, files: [] };
  }

  // Fonction pour générer un nom de dossier aléatoire de 6 caractères
  const generateRandomDirectoryName = () => {
    return Math.random().toString(36).substring(2, 8);
  };

  // Créer un répertoire temporaire avec un nom aléatoire
  const tempUploadDirectoryName = generateRandomDirectoryName();
  const uploadsDirectory = path.join(process.cwd(), 'tmp', 'uploads', tempUploadDirectoryName);
  const remoteFilePath = '/tmp/test';
  const resultFiles: { name: string; success: boolean; error?: string; }[] = [];
  const sftp = new SFTPClient();

  try {
    await sftp.connect({ host: 'tpiiusa003' });

    // Créer le répertoire s'il n'existe pas
    try {
      if (!fs.existsSync(uploadsDirectory)) {
        fs.mkdirSync(uploadsDirectory, { recursive: true });
      }
    } catch (error) {
      const errorMessage = `Erreur lors de la création du répertoire de destination "${uploadsDirectory}".`;
      console.error(errorMessage, error);
      return { message: errorMessage, success: false, files: resultFiles };
    }

    // Gestion d'erreur
    try {
      for (const file of formData) {
        const fileBuffer: Buffer = file.data;
        if (!file.filename) {
          const errorMessage = 'Le nom du fichier est indéfini.';
          console.error(errorMessage);
          resultFiles.push({ name: 'Indéfini', success: false, error: errorMessage });
          continue;
        }

        const filePath = path.join(uploadsDirectory, file.filename);

        try {
          fs.writeFileSync(filePath, fileBuffer);
          await sftp.uploadFile(filePath, remoteFilePath);
          resultFiles.push({ name: file.filename, success: true });
        } catch (error) {
          const errorMessage = `Erreur lors de l'enregistrement du fichier: ${file.filename}`;
          console.error(errorMessage, error);
          resultFiles.push({ name: file.filename, success: false, error: errorMessage });
        }
      }

      return { message: 'Fichiers traités.', success: true, files: resultFiles };
    } catch (error) {
      console.error('Erreur lors de l\'enregistrement des fichiers :', error);
      return { message: 'Erreur lors de l\'enregistrement des fichiers.', success: false, files: resultFiles };
    }
  } catch (error) {
    console.error('Erreur lors de la connexion SFTP:', error);
    throw createError({ statusCode: 500, statusMessage: 'Erreur lors de la connexion SFTP' });
  } finally {
    sftp.close();

    // Supprimer le répertoire temporaire des uploads
    try {
      fs.rmSync(uploadsDirectory, { recursive: true, force: true });
      console.log(`Répertoire temporaire supprimé : ${uploadsDirectory}`);
    } catch (error) {
      console.error(`Erreur lors de la suppression du répertoire temporaire : ${uploadsDirectory}`, error);
    }
  }
});

et 
download.ts  
import fs from 'fs';
import path from 'path';
import archiver from 'archiver';
import { SFTPClient } from '~/services/sftp.service';

export default defineEventHandler(async (event) => {
    const body = await readBody(event); // Lire le corps de la requête pour obtenir la liste des noms de fichiers
    const { filenames } = body;

    console.log("Filenames reçus:", filenames); // Log des noms de fichiers reçus

    if (!Array.isArray(filenames) || filenames.length === 0) {
        console.error("Aucun fichier sélectionné ou format incorrect");
        throw createError({ statusCode: 400, statusMessage: 'Filenames nécessaire' });
    }

    // Fonction pour générer un nom de dossier aléatoire de 6 caractères
    const generateRandomDirectoryName = () => {
        return Math.random().toString(36).substring(2, 8);
    };

    // Créer des répertoires temporaires avec des noms aléatoires
    const tempUploadDirectoryName = generateRandomDirectoryName();
    const uploadDir = path.join(process.cwd(), 'tmp', 'uploads', tempUploadDirectoryName);

    const tempZipDirectoryName = generateRandomDirectoryName();
    const zipDir = path.join(process.cwd(), 'tmp', 'zipfiles', tempZipDirectoryName);
    const zipFilePath = path.join(zipDir, 'fichier.zip');

    const sftp = new SFTPClient();

    try {
        await sftp.connect({ host: 'tpiiusa003' });

        // Créer les répertoires nécessaires s'ils n'existent pas
        try {
            if (!fs.existsSync(uploadDir)) {
                fs.mkdirSync(uploadDir, { recursive: true });
            }
            if (!fs.existsSync(zipDir)) {
                fs.mkdirSync(zipDir, { recursive: true });
            }
        } catch (error) {
            const errorMessage = `Erreur lors de la création des répertoires nécessaires.`;
            console.error(errorMessage, error);
            throw createError({ statusCode: 500, statusMessage: errorMessage });
        }

        console.log("Création de l'archive...");
        // Créer un fichier pour diffuser les données de l'archive.
        const output = fs.createWriteStream(zipFilePath);
        const archive = archiver('zip', {
            zlib: { level: 9 } // Niveau de compression.
        });

        // Configure archiver pour écrire les données de l'archive dans le flux de sortie
        archive.pipe(output);

        for (const filename of filenames) {
            const file = path.join(uploadDir, filename.name);
            const dst = fs.createWriteStream(file);
            await sftp.downloadFile(filename.pathFull, dst);

            if (fs.existsSync(file)) {
                console.log(`Ajout du fichier: ${filename.name}`);
                archive.file(file, { name: filename.name });
                dst.close();
            } else {
                console.warn(`Fichier non trouvé: ${filename.name}`);
            }
        }

        await archive.finalize();

        // Supprimer les fichiers téléchargés
        for (const filename of filenames) {
            const file = path.join(uploadDir, filename.name);
            if (fs.existsSync(file)) {
                fs.rmSync(file);
            }
        }

        console.log("Archivage finalisé.");

        // Attendre que le flux de sortie soit fermé avant de lire le fichier ZIP
        await new Promise((resolve, reject) => {
            output.on('close', resolve);
            output.on('error', reject);
        });

        console.log("Lecture du fichier ZIP généré...");
        // Lire le fichier ZIP généré
        const zipFile = await fs.promises.readFile(zipFilePath);
        console.log("Fichier ZIP généré avec succès.");
        return zipFile; // Retourner directement le fichier ZIP

    } catch (error) {
        console.error('Erreur lors de la création du fichier ZIP:', error);
        throw createError({ statusCode: 500, statusMessage: 'Erreur lors de la création du fichier ZIP' });
    } finally {
        sftp.close();

        // Supprimer le répertoire temporaire des uploads
        try {
            fs.rmSync(uploadDir, { recursive: true, force: true });
            console.log(`Répertoire temporaire supprimé : ${uploadDir}`);
        } catch (error) {
            console.error(`Erreur lors de la suppression du répertoire temporaire des uploads : ${uploadDir}`, error);
        }

        // Supprimer le répertoire temporaire des zipfiles
        try {
            fs.rmSync(zipDir, { recursive: true, force: true });
            console.log(`Répertoire temporaire supprimé : ${zipDir}`);
        } catch (error) {
            console.error(`Erreur lors de la suppression du répertoire temporaire des zipfiles : ${zipDir}`, error);
        }
    }
});
